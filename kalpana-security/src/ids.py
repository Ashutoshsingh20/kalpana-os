#!/usr/bin/env python3
"""
Kalpana Intrusion Detection System (IDS)
========================================
Signature-based and anomaly-based intrusion detection.
"""

import asyncio
import json
import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Set, Pattern
from collections import defaultdict
import hashlib

# ============================================================================
# Signature Database
# ============================================================================

class SignatureCategory(Enum):
    RECONNAISSANCE = "reconnaissance"
    EXPLOITATION = "exploitation"
    COMMAND_CONTROL = "command_and_control"
    DATA_EXFILTRATION = "data_exfiltration"
    MALWARE = "malware"
    POLICY_VIOLATION = "policy_violation"


@dataclass
class IDSSignature:
    """IDS detection signature."""
    id: str
    name: str
    category: SignatureCategory
    description: str
    pattern: str  # Regex pattern
    compiled: Optional[Pattern] = None
    severity: int = 5  # 1-10
    enabled: bool = True
    
    def __post_init__(self):
        if self.pattern:
            try:
                self.compiled = re.compile(self.pattern, re.IGNORECASE)
            except re.error:
                logging.warning(f"Invalid pattern for signature {self.id}")


@dataclass
class IDSAlert:
    """Alert generated by IDS."""
    id: str
    timestamp: datetime
    signature: IDSSignature
    source_ip: str
    dest_ip: str
    matched_content: str
    raw_data: bytes


# ============================================================================
# Built-in Signatures
# ============================================================================

BUILTIN_SIGNATURES = [
    IDSSignature(
        id="KALPANA-RECON-001",
        name="Nmap SYN Scan Detected",
        category=SignatureCategory.RECONNAISSANCE,
        description="Detected possible Nmap SYN scan activity",
        pattern=r"SYN.*scan|nmap",
        severity=4
    ),
    IDSSignature(
        id="KALPANA-RECON-002",
        name="SSH Brute Force Attempt",
        category=SignatureCategory.RECONNAISSANCE,
        description="Multiple failed SSH login attempts detected",
        pattern=r"Failed password.*ssh|invalid user.*ssh",
        severity=6
    ),
    IDSSignature(
        id="KALPANA-EXPLOIT-001",
        name="SQL Injection Attempt",
        category=SignatureCategory.EXPLOITATION,
        description="SQL injection pattern detected in request",
        pattern=r"('|\")\s*(or|and)\s*('|\"|\d).*=|union\s+select|drop\s+table",
        severity=8
    ),
    IDSSignature(
        id="KALPANA-EXPLOIT-002",
        name="Command Injection Attempt",
        category=SignatureCategory.EXPLOITATION,
        description="OS command injection pattern detected",
        pattern=r";\s*(cat|ls|id|whoami|uname|pwd)\s*|`.*`|\$\(.*\)",
        severity=9
    ),
    IDSSignature(
        id="KALPANA-EXPLOIT-003",
        name="Path Traversal Attempt",
        category=SignatureCategory.EXPLOITATION,
        description="Directory traversal attack detected",
        pattern=r"\.\./|\.\.\\|%2e%2e|%252e%252e",
        severity=7
    ),
    IDSSignature(
        id="KALPANA-C2-001",
        name="Known C2 User-Agent",
        category=SignatureCategory.COMMAND_CONTROL,
        description="Known malware user-agent string detected",
        pattern=r"Cobalt\s*Strike|Meterpreter|Empire|Covenant",
        severity=10
    ),
    IDSSignature(
        id="KALPANA-C2-002",
        name="Base64 Encoded Command",
        category=SignatureCategory.COMMAND_CONTROL,
        description="Potentially obfuscated command detected",
        pattern=r"powershell.*-enc|-encodedcommand|base64\s*-d",
        severity=8
    ),
    IDSSignature(
        id="KALPANA-EXFIL-001",
        name="Potential Data Exfiltration",
        category=SignatureCategory.DATA_EXFILTRATION,
        description="Large outbound data transfer pattern",
        pattern=r"POST.*large|upload.*data|exfil",
        severity=7
    ),
    IDSSignature(
        id="KALPANA-MALWARE-001",
        name="Known Malware Hash",
        category=SignatureCategory.MALWARE,
        description="File hash matches known malware",
        pattern=r"",  # Hash-based, handled separately
        severity=10,
        enabled=False  # Requires file analysis
    ),
    IDSSignature(
        id="KALPANA-POLICY-001",
        name="Cleartext Password Transmission",
        category=SignatureCategory.POLICY_VIOLATION,
        description="Password sent over unencrypted connection",
        pattern=r"password=|passwd=|pwd=",
        severity=6
    ),
]


# ============================================================================
# Anomaly Detection
# ============================================================================

class AnomalyDetector:
    """
    Statistical anomaly detection for network behavior.
    Builds baseline and detects deviations.
    """
    
    def __init__(self):
        # Baseline statistics per source
        self.baselines: Dict[str, Dict] = {}
        self.learning_period = 3600  # 1 hour in seconds
        self.started_at = datetime.now()
        
    def is_learning(self) -> bool:
        """Check if still in learning mode."""
        return (datetime.now() - self.started_at).seconds < self.learning_period
    
    def record_activity(self, source_ip: str, bytes_sent: int, 
                       packets: int, unique_destinations: int):
        """Record activity for baseline building."""
        if source_ip not in self.baselines:
            self.baselines[source_ip] = {
                "samples": [],
                "mean_bytes": 0,
                "mean_packets": 0,
                "mean_dests": 0,
                "std_bytes": 0,
                "std_packets": 0,
                "std_dests": 0
            }
        
        baseline = self.baselines[source_ip]
        baseline["samples"].append({
            "bytes": bytes_sent,
            "packets": packets,
            "dests": unique_destinations,
            "time": datetime.now()
        })
        
        # Keep only last 100 samples
        baseline["samples"] = baseline["samples"][-100:]
        
        # Update statistics
        if len(baseline["samples"]) > 5:
            bytes_list = [s["bytes"] for s in baseline["samples"]]
            packets_list = [s["packets"] for s in baseline["samples"]]
            dests_list = [s["dests"] for s in baseline["samples"]]
            
            baseline["mean_bytes"] = sum(bytes_list) / len(bytes_list)
            baseline["mean_packets"] = sum(packets_list) / len(packets_list)
            baseline["mean_dests"] = sum(dests_list) / len(dests_list)
    
    def check_anomaly(self, source_ip: str, bytes_sent: int,
                      packets: int, unique_destinations: int) -> Optional[str]:
        """Check if activity is anomalous."""
        if self.is_learning():
            return None
        
        if source_ip not in self.baselines:
            return None
        
        baseline = self.baselines[source_ip]
        
        # Simple threshold-based detection
        if baseline["mean_bytes"] > 0:
            if bytes_sent > baseline["mean_bytes"] * 10:
                return f"Unusual data volume: {bytes_sent} bytes (avg: {baseline['mean_bytes']:.0f})"
        
        if baseline["mean_dests"] > 0:
            if unique_destinations > baseline["mean_dests"] * 5:
                return f"Unusual destination count: {unique_destinations} (avg: {baseline['mean_dests']:.0f})"
        
        return None


# ============================================================================
# Intrusion Detection System
# ============================================================================

class IntrusionDetectionSystem:
    """
    Main IDS engine combining signature and anomaly detection.
    """
    
    def __init__(self):
        self.signatures = BUILTIN_SIGNATURES.copy()
        self.anomaly_detector = AnomalyDetector()
        self.alerts: List[IDSAlert] = []
        self.alert_counter = 0
        
        # Load custom signatures if available
        self._load_custom_signatures()
        
        enabled_count = sum(1 for s in self.signatures if s.enabled)
        logging.info(f"ğŸ” IDS initialized with {enabled_count} signatures")
    
    def _load_custom_signatures(self):
        """Load custom signatures from file."""
        custom_path = "/tmp/kalpana-security/custom_signatures.json"
        try:
            if os.path.exists(custom_path):
                with open(custom_path) as f:
                    custom = json.load(f)
                    for sig_data in custom.get("signatures", []):
                        self.signatures.append(IDSSignature(**sig_data))
        except Exception as e:
            logging.debug(f"No custom signatures: {e}")
    
    def _generate_alert_id(self) -> str:
        self.alert_counter += 1
        return f"IDS-{datetime.now().strftime('%Y%m%d%H%M%S')}-{self.alert_counter:04d}"
    
    def analyze_payload(self, data: bytes, source_ip: str, 
                       dest_ip: str) -> List[IDSAlert]:
        """Analyze packet payload against signatures."""
        alerts = []
        
        try:
            text_data = data.decode('utf-8', errors='ignore')
        except:
            text_data = str(data)
        
        for sig in self.signatures:
            if not sig.enabled or not sig.compiled:
                continue
            
            match = sig.compiled.search(text_data)
            if match:
                alert = IDSAlert(
                    id=self._generate_alert_id(),
                    timestamp=datetime.now(),
                    signature=sig,
                    source_ip=source_ip,
                    dest_ip=dest_ip,
                    matched_content=match.group()[:100],  # Truncate
                    raw_data=data[:500]  # Truncate
                )
                alerts.append(alert)
                self.alerts.append(alert)
                
                logging.warning(
                    f"ğŸš¨ IDS ALERT [{sig.id}]: {sig.name} "
                    f"({source_ip} -> {dest_ip})"
                )
        
        return alerts
    
    def analyze_hash(self, file_hash: str, algorithm: str = "sha256") -> Optional[IDSAlert]:
        """Check file hash against known malware."""
        # In production, this would query VirusTotal, MISP, etc.
        known_bad_hashes = {
            "e3b0c44298fc1c149afbf4c8996fb924": "Empty file (test)",
        }
        
        if file_hash.lower() in known_bad_hashes:
            sig = IDSSignature(
                id="KALPANA-HASH-MATCH",
                name=f"Known Malware: {known_bad_hashes[file_hash]}",
                category=SignatureCategory.MALWARE,
                description="File hash matches known malware signature",
                pattern="",
                severity=10
            )
            
            return IDSAlert(
                id=self._generate_alert_id(),
                timestamp=datetime.now(),
                signature=sig,
                source_ip="local",
                dest_ip="local",
                matched_content=file_hash,
                raw_data=b""
            )
        
        return None
    
    def get_alerts(self, limit: int = 100) -> List[Dict]:
        """Get recent IDS alerts."""
        return [
            {
                "id": a.id,
                "timestamp": a.timestamp.isoformat(),
                "signature_id": a.signature.id,
                "signature_name": a.signature.name,
                "category": a.signature.category.value,
                "severity": a.signature.severity,
                "source": a.source_ip,
                "dest": a.dest_ip,
                "matched": a.matched_content
            }
            for a in self.alerts[-limit:]
        ]
    
    def get_statistics(self) -> Dict:
        """Get IDS statistics."""
        category_counts = defaultdict(int)
        severity_counts = defaultdict(int)
        
        for alert in self.alerts:
            category_counts[alert.signature.category.value] += 1
            severity_counts[alert.signature.severity] += 1
        
        return {
            "total_alerts": len(self.alerts),
            "by_category": dict(category_counts),
            "by_severity": dict(severity_counts),
            "signatures_loaded": len(self.signatures),
            "anomaly_mode": "learning" if self.anomaly_detector.is_learning() else "active"
        }


# Need os import
import os

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    ids = IntrusionDetectionSystem()
    
    # Test with sample payloads
    test_payloads = [
        b"GET /login?user=admin&password=test123",
        b"GET /page?id=1' OR '1'='1",
        b"GET /../../../etc/passwd",
        b"User-Agent: Cobalt Strike",
        b"Normal HTTP traffic here",
    ]
    
    print("\nğŸ” Testing IDS Signatures:\n")
    for payload in test_payloads:
        alerts = ids.analyze_payload(payload, "10.0.0.1", "192.168.1.1")
        if alerts:
            for a in alerts:
                print(f"  ğŸš¨ {a.signature.name}: {a.matched_content}")
        else:
            print(f"  âœ… Clean: {payload[:50]}")
    
    print("\nğŸ“Š Statistics:")
    print(json.dumps(ids.get_statistics(), indent=2))
