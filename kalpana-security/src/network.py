#!/usr/bin/env python3
"""
Kalpana Security Module - Network Stack
========================================
Real-time network monitoring, packet capture, and threat detection.
Part of Kalpana OS security infrastructure.
"""

import asyncio
import json
import logging
import os
import socket
import struct
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Set, Callable
from collections import defaultdict
import subprocess

# ============================================================================
# Configuration
# ============================================================================

DEV_MODE = os.environ.get("KALPANA_DEV_MODE", "1") == "1"
LOG_DIR = "/tmp/kalpana-security" if DEV_MODE else "/kalpana/security/logs"

# ============================================================================
# Enums & Data Classes
# ============================================================================

class ThreatLevel(Enum):
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ConnectionState(Enum):
    NEW = "new"
    ESTABLISHED = "established"
    SUSPICIOUS = "suspicious"
    BLOCKED = "blocked"


@dataclass
class NetworkConnection:
    """Represents a network connection."""
    src_ip: str
    src_port: int
    dst_ip: str
    dst_port: int
    protocol: str
    state: ConnectionState
    bytes_sent: int = 0
    bytes_recv: int = 0
    first_seen: datetime = field(default_factory=datetime.now)
    last_seen: datetime = field(default_factory=datetime.now)
    pid: Optional[int] = None
    process_name: Optional[str] = None


@dataclass
class NetworkAlert:
    """Security alert generated by the network monitor."""
    id: str
    timestamp: datetime
    threat_level: ThreatLevel
    title: str
    description: str
    connection: Optional[NetworkConnection]
    recommended_action: str
    auto_action_taken: Optional[str] = None


@dataclass
class Device:
    """Network device/host."""
    ip: str
    mac: Optional[str]
    hostname: Optional[str]
    first_seen: datetime
    last_seen: datetime
    is_local: bool = False
    is_gateway: bool = False
    is_trusted: bool = False
    ports_open: Set[int] = field(default_factory=set)


# ============================================================================
# Firewall Manager
# ============================================================================

class FirewallManager:
    """
    Manages firewall rules on the host.
    Uses nftables/iptables on Linux.
    """
    
    def __init__(self):
        self.rules: List[Dict] = []
        self.blocked_ips: Set[str] = set()
        
    async def block_ip(self, ip: str, reason: str, duration_seconds: int = 3600) -> bool:
        """Block an IP address."""
        if ip in self.blocked_ips:
            return True
            
        logging.info(f"ğŸ”¥ FIREWALL: Blocking {ip} - {reason}")
        
        # On actual Linux, run:
        # sudo nft add rule inet filter input ip saddr {ip} drop
        
        self.blocked_ips.add(ip)
        self.rules.append({
            "type": "block",
            "ip": ip,
            "reason": reason,
            "created": datetime.now().isoformat(),
            "expires": (datetime.now().timestamp() + duration_seconds)
        })
        
        return True
    
    async def unblock_ip(self, ip: str) -> bool:
        """Unblock an IP address."""
        if ip not in self.blocked_ips:
            return True
            
        logging.info(f"ğŸ”“ FIREWALL: Unblocking {ip}")
        self.blocked_ips.discard(ip)
        self.rules = [r for r in self.rules if r.get("ip") != ip]
        
        return True
    
    async def allow_port(self, port: int, protocol: str = "tcp") -> bool:
        """Allow incoming connections on a port."""
        logging.info(f"âœ… FIREWALL: Allowing {protocol}/{port}")
        
        self.rules.append({
            "type": "allow_port",
            "port": port,
            "protocol": protocol,
            "created": datetime.now().isoformat()
        })
        
        return True
    
    def get_rules(self) -> List[Dict]:
        """Get all active firewall rules."""
        return self.rules.copy()


# ============================================================================
# Threat Detector
# ============================================================================

class ThreatDetector:
    """
    Analyzes network traffic for threats.
    Implements heuristics and pattern matching.
    """
    
    # Known malicious ports
    SUSPICIOUS_PORTS = {
        4444: "Metasploit default",
        5555: "Android ADB",
        6666: "IRC (potential C2)",
        31337: "Back Orifice",
        12345: "NetBus",
        1337: "Elite/L33t port",
    }
    
    # Port scan detection
    PORTSCAN_THRESHOLD = 10  # connections to different ports in 60s
    PORTSCAN_WINDOW = 60  # seconds
    
    def __init__(self):
        self.connection_history: Dict[str, List[datetime]] = defaultdict(list)
        self.alert_counter = 0
        
    def _generate_alert_id(self) -> str:
        self.alert_counter += 1
        return f"ALERT-{datetime.now().strftime('%Y%m%d%H%M%S')}-{self.alert_counter:04d}"
    
    def analyze_connection(self, conn: NetworkConnection) -> Optional[NetworkAlert]:
        """Analyze a connection for threats."""
        
        # Check for suspicious ports
        if conn.dst_port in self.SUSPICIOUS_PORTS:
            return NetworkAlert(
                id=self._generate_alert_id(),
                timestamp=datetime.now(),
                threat_level=ThreatLevel.HIGH,
                title=f"Suspicious Port Access: {conn.dst_port}",
                description=f"Connection to {self.SUSPICIOUS_PORTS[conn.dst_port]} port detected",
                connection=conn,
                recommended_action="Block source IP and investigate"
            )
        
        # Check for port scan behavior
        key = conn.src_ip
        now = datetime.now()
        
        # Clean old entries
        self.connection_history[key] = [
            t for t in self.connection_history[key]
            if (now - t).seconds < self.PORTSCAN_WINDOW
        ]
        
        self.connection_history[key].append(now)
        
        if len(self.connection_history[key]) > self.PORTSCAN_THRESHOLD:
            return NetworkAlert(
                id=self._generate_alert_id(),
                timestamp=now,
                threat_level=ThreatLevel.MEDIUM,
                title=f"Potential Port Scan from {conn.src_ip}",
                description=f"Detected {len(self.connection_history[key])} connections in {self.PORTSCAN_WINDOW}s",
                connection=conn,
                recommended_action="Consider blocking source IP"
            )
        
        return None


# ============================================================================
# Network Monitor
# ============================================================================

class NetworkMonitor:
    """
    Main network monitoring daemon.
    Captures traffic, tracks connections, detects threats.
    """
    
    def __init__(self):
        self.running = False
        self.connections: Dict[str, NetworkConnection] = {}
        self.devices: Dict[str, Device] = {}
        self.alerts: List[NetworkAlert] = []
        self.firewall = FirewallManager()
        self.detector = ThreatDetector()
        self.alert_callbacks: List[Callable] = []
        
        # Ensure log directory
        os.makedirs(LOG_DIR, exist_ok=True)
        
        logging.info("ğŸ”’ Network Security Monitor initialized")
    
    def _connection_key(self, src_ip: str, src_port: int, 
                        dst_ip: str, dst_port: int) -> str:
        """Generate unique key for a connection."""
        return f"{src_ip}:{src_port}-{dst_ip}:{dst_port}"
    
    async def start(self):
        """Start the network monitor."""
        self.running = True
        logging.info("ğŸŒ Starting Network Monitor...")
        
        # Start monitoring tasks
        await asyncio.gather(
            self._monitor_connections(),
            self._monitor_arp(),
            self._process_alerts(),
            self._cleanup_old_data()
        )
    
    async def stop(self):
        """Stop the network monitor."""
        self.running = False
        logging.info("ğŸ›‘ Network Monitor stopped")
    
    async def _monitor_connections(self):
        """Monitor active network connections."""
        while self.running:
            try:
                # Get current connections using netstat/ss
                result = subprocess.run(
                    ["netstat", "-an"],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                
                # Parse connections (simplified)
                for line in result.stdout.split('\n'):
                    if 'ESTABLISHED' in line or 'LISTEN' in line:
                        conn = self._parse_netstat_line(line)
                        if conn:
                            await self._process_connection(conn)
                
            except Exception as e:
                logging.error(f"Connection monitor error: {e}")
            
            await asyncio.sleep(2)
    
    def _parse_netstat_line(self, line: str) -> Optional[NetworkConnection]:
        """Parse a netstat output line."""
        try:
            parts = line.split()
            if len(parts) < 5:
                return None
            
            proto = parts[0].lower()
            if proto not in ['tcp', 'tcp4', 'tcp6', 'udp', 'udp4', 'udp6']:
                return None
            
            # Parse local address
            local = parts[3] if len(parts) > 3 else ""
            remote = parts[4] if len(parts) > 4 else ""
            
            if '.' in local:
                local_parts = local.rsplit('.', 1)
                src_ip = local_parts[0]
                src_port = int(local_parts[1]) if local_parts[1] != '*' else 0
            else:
                return None
                
            if '.' in remote:
                remote_parts = remote.rsplit('.', 1)
                dst_ip = remote_parts[0]
                dst_port = int(remote_parts[1]) if remote_parts[1] != '*' else 0
            else:
                dst_ip = "0.0.0.0"
                dst_port = 0
            
            return NetworkConnection(
                src_ip=src_ip,
                src_port=src_port,
                dst_ip=dst_ip,
                dst_port=dst_port,
                protocol=proto.replace('4', '').replace('6', ''),
                state=ConnectionState.ESTABLISHED
            )
            
        except Exception:
            return None
    
    async def _process_connection(self, conn: NetworkConnection):
        """Process a connection - store and analyze."""
        key = self._connection_key(conn.src_ip, conn.src_port, 
                                   conn.dst_ip, conn.dst_port)
        
        # Update or add connection
        if key in self.connections:
            self.connections[key].last_seen = datetime.now()
        else:
            self.connections[key] = conn
            
            # Analyze new connection for threats
            alert = self.detector.analyze_connection(conn)
            if alert:
                await self._handle_alert(alert)
    
    async def _monitor_arp(self):
        """Monitor ARP table for new devices."""
        while self.running:
            try:
                # Get ARP table
                result = subprocess.run(
                    ["arp", "-a"],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                
                for line in result.stdout.split('\n'):
                    device = self._parse_arp_line(line)
                    if device:
                        if device.ip not in self.devices:
                            logging.info(f"ğŸ“± New device discovered: {device.ip} ({device.mac})")
                            # Generate alert for new device
                            await self._handle_alert(NetworkAlert(
                                id=self.detector._generate_alert_id(),
                                timestamp=datetime.now(),
                                threat_level=ThreatLevel.INFO,
                                title=f"New Device: {device.ip}",
                                description=f"MAC: {device.mac or 'Unknown'}",
                                connection=None,
                                recommended_action="Verify device is trusted"
                            ))
                        self.devices[device.ip] = device
                        
            except Exception as e:
                logging.debug(f"ARP monitor error: {e}")
            
            await asyncio.sleep(30)
    
    def _parse_arp_line(self, line: str) -> Optional[Device]:
        """Parse an ARP table line."""
        try:
            # Format: hostname (ip) at mac on interface
            if '(' not in line or ')' not in line:
                return None
            
            ip_start = line.index('(') + 1
            ip_end = line.index(')')
            ip = line[ip_start:ip_end]
            
            mac = None
            if ' at ' in line:
                mac_part = line.split(' at ')[1].split()[0]
                if ':' in mac_part or '-' in mac_part:
                    mac = mac_part
            
            return Device(
                ip=ip,
                mac=mac,
                hostname=line.split()[0] if line.split()[0] != '?' else None,
                first_seen=datetime.now(),
                last_seen=datetime.now()
            )
            
        except Exception:
            return None
    
    async def _handle_alert(self, alert: NetworkAlert):
        """Handle a security alert."""
        self.alerts.append(alert)
        
        # Log alert
        logging.warning(f"ğŸš¨ [{alert.threat_level.value.upper()}] {alert.title}")
        
        # Write to file
        with open(os.path.join(LOG_DIR, "alerts.json"), "a") as f:
            f.write(json.dumps({
                "id": alert.id,
                "timestamp": alert.timestamp.isoformat(),
                "level": alert.threat_level.value,
                "title": alert.title,
                "description": alert.description
            }) + "\n")
        
        # Auto-response for critical threats
        if alert.threat_level == ThreatLevel.CRITICAL and alert.connection:
            await self.firewall.block_ip(
                alert.connection.src_ip,
                f"Auto-blocked: {alert.title}"
            )
            alert.auto_action_taken = f"Blocked {alert.connection.src_ip}"
        
        # Notify callbacks
        for callback in self.alert_callbacks:
            try:
                await callback(alert)
            except Exception as e:
                logging.error(f"Alert callback error: {e}")
    
    async def _process_alerts(self):
        """Background alert processing."""
        while self.running:
            # Future: correlation, aggregation, etc.
            await asyncio.sleep(5)
    
    async def _cleanup_old_data(self):
        """Clean up old connections and data."""
        while self.running:
            now = datetime.now()
            
            # Remove connections not seen in 5 minutes
            stale_keys = []
            for key, conn in self.connections.items():
                if (now - conn.last_seen).seconds > 300:
                    stale_keys.append(key)
            
            for key in stale_keys:
                del self.connections[key]
            
            # Keep only last 1000 alerts
            if len(self.alerts) > 1000:
                self.alerts = self.alerts[-1000:]
            
            await asyncio.sleep(60)
    
    def get_status(self) -> Dict:
        """Get current network security status."""
        threat_counts = defaultdict(int)
        for alert in self.alerts[-100:]:
            threat_counts[alert.threat_level.value] += 1
        
        return {
            "active_connections": len(self.connections),
            "known_devices": len(self.devices),
            "blocked_ips": len(self.firewall.blocked_ips),
            "recent_alerts": len(self.alerts),
            "threat_summary": dict(threat_counts),
            "firewall_rules": len(self.firewall.rules)
        }
    
    def get_alerts(self, limit: int = 50) -> List[Dict]:
        """Get recent alerts."""
        return [
            {
                "id": a.id,
                "timestamp": a.timestamp.isoformat(),
                "level": a.threat_level.value,
                "title": a.title,
                "description": a.description,
                "action": a.recommended_action,
                "auto_action": a.auto_action_taken
            }
            for a in self.alerts[-limit:]
        ]


# ============================================================================
# Entry Point
# ============================================================================

async def main():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s | %(levelname)s | %(message)s'
    )
    
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                           â•‘
    â•‘    ğŸ›¡ï¸  KALPANA NETWORK SECURITY DAEMON                    â•‘
    â•‘                                                           â•‘
    â•‘    Real-time threat detection and network monitoring      â•‘
    â•‘                                                           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    monitor = NetworkMonitor()
    
    try:
        await monitor.start()
    except KeyboardInterrupt:
        pass
    finally:
        await monitor.stop()


if __name__ == "__main__":
    asyncio.run(main())
